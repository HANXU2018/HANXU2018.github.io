<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>day02【Collection、泛型】 | 慧河工作室</title>
<link rel="shortcut icon" href="https://huihe524.github.io/favicon.ico?v=1585653260972">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://huihe524.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="day02【Collection、泛型】 | 慧河工作室 - Atom Feed" href="https://huihe524.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="的风格森岛帆高上地方
day02【Collection、泛型】
主要内容

Collection集合
迭代器
增强for
泛型

教学目标

 能够说出集合与数组的区别
 说出Collection集合的常用功能
 能够使用迭代器对集合进行取..." />
    <meta name="keywords" content="JavaGroup1" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://huihe524.github.io">
  <img class="avatar" src="https://huihe524.github.io/images/avatar.png?v=1585653260972" alt="">
  </a>
  <h1 class="site-title">
    慧河工作室
  </h1>
  <p class="site-description">
    河北大学网络空间安全与计算机学院慧河工作室
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/tag/SLW_bGLeB/" class="menu">
          JavaGroup1
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/huihe524" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              day02【Collection、泛型】
            </h2>
            <div class="post-info">
              <span>
                2020-03-31
              </span>
              <span>
                20 min read
              </span>
              
                <a href="https://huihe524.github.io/tag/SLW_bGLeB/" class="post-tag">
                  # JavaGroup1
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://i.loli.net/2020/03/31/PYD64nc8JqChlw7.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>的风格森岛帆高上地方</p>
<h1 id="day02collection-泛型">day02【Collection、泛型】</h1>
<h2 id="主要内容">主要内容</h2>
<ul>
<li>Collection集合</li>
<li>迭代器</li>
<li>增强for</li>
<li>泛型</li>
</ul>
<h2 id="教学目标">教学目标</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4974590"><label class="task-list-item-label" for="task-item-4974590"> 能够说出集合与数组的区别</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5005337"><label class="task-list-item-label" for="task-item-5005337"> 说出Collection集合的常用功能</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1850331"><label class="task-list-item-label" for="task-item-1850331"> 能够使用迭代器对集合进行取元素</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1600266"><label class="task-list-item-label" for="task-item-1600266"> 能够说出集合的使用细节</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7981955"><label class="task-list-item-label" for="task-item-7981955"> 能够使用集合存储自定义类型</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4970763"><label class="task-list-item-label" for="task-item-4970763"> 能够使用foreach循环遍历集合</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-9105987"><label class="task-list-item-label" for="task-item-9105987"> 能够使用泛型定义集合对象</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-3137056"><label class="task-list-item-label" for="task-item-3137056"> 能够理解泛型上下限</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1865990"><label class="task-list-item-label" for="task-item-1865990"> 能够阐述泛型通配符的作用</label></li>
</ul>
<h1 id="第一章-collection集合">第一章 Collection集合</h1>
<h2 id="11-集合概述">1.1 集合概述</h2>
<p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p>
<ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="12-集合框架">1.2  集合框架</h2>
<p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<figure data-type="image" tabindex="1"><img src="img%5CCollection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.png" alt="" loading="lazy"></figure>
<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="13-collection-常用功能">1.3 Collection 常用功能</h2>
<p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Collection;

public class Demo1Collection {
    public static void main(String[] args) {
		// 创建集合对象 
    	// 使用多态形式
    	Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
    	// 使用方法
    	// 添加功能  boolean  add(String s)
    	coll.add(&quot;小李广&quot;);
    	coll.add(&quot;扫地僧&quot;);
    	coll.add(&quot;石破天&quot;);
    	System.out.println(coll);

    	// boolean contains(E e) 判断o是否在集合中存在
    	System.out.println(&quot;判断  扫地僧 是否在集合中&quot;+coll.contains(&quot;扫地僧&quot;));

    	//boolean remove(E e) 删除在集合中的o元素
    	System.out.println(&quot;删除石破天：&quot;+coll.remove(&quot;石破天&quot;));
    	System.out.println(&quot;操作之后集合中元素:&quot;+coll);
    	
    	// size() 集合中有几个元素
		System.out.println(&quot;集合中有&quot;+coll.size()+&quot;个元素&quot;);

		// Object[] toArray()转换成一个Object数组
    	Object[] objects = coll.toArray();
    	// 遍历数组
    	for (int i = 0; i &lt; objects.length; i++) {
			System.out.println(objects[i]);
		}

		// void  clear() 清空集合
		coll.clear();
		System.out.println(&quot;集合中内容为：&quot;+coll);
		// boolean  isEmpty()  判断是否为空
		System.out.println(coll.isEmpty());  	
	}
}
</code></pre>
<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h2 id="第二章-iterator迭代器">第二章 Iterator迭代器</h2>
<h2 id="21-iterator接口">2.1 Iterator接口</h2>
<p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<pre><code class="language-java">public class IteratorDemo {
  	public static void main(String[] args) {
        // 使用多态方式 创建对象
        Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();

        // 添加元素到集合
        coll.add(&quot;串串星人&quot;);
        coll.add(&quot;吐槽星人&quot;);
        coll.add(&quot;汪星人&quot;);
        //遍历
        //使用迭代器 遍历   每个集合对象都有自己的迭代器
        Iterator&lt;String&gt; it = coll.iterator();
        //  泛型指的是 迭代出 元素的数据类型
        while(it.hasNext()){ //判断是否有迭代元素
            String s = it.next();//获取迭代出的元素
            System.out.println(s);
        }
  	}
}
</code></pre>
<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="22-迭代器的实现原理">2.2 迭代器的实现原理</h2>
<p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<figure data-type="image" tabindex="2"><img src="img%5C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp" alt="" loading="lazy"></figure>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="23-增强for">2.3 增强for</h2>
<p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<pre><code class="language-java">for(元素的数据类型  变量 : Collection集合or数组){ 
  	//写操作代码
}
</code></pre>
<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="练习1遍历数组">练习1：遍历数组</h4>
<pre><code class="language-java">public class NBForDemo1 {
    public static void main(String[] args) {
		int[] arr = {3,5,6,87};
       	//使用增强for遍历数组
		for(int a : arr){//a代表数组中的每个元素
			System.out.println(a);
		}
	}
}
</code></pre>
<h4 id="练习2遍历集合">练习2:遍历集合</h4>
<pre><code class="language-java">public class NBFor {
    public static void main(String[] args) {        
    	Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;();
    	coll.add(&quot;小河神&quot;);
    	coll.add(&quot;老河神&quot;);
    	coll.add(&quot;神婆&quot;);
    	//使用增强for遍历
    	for(String s :coll){//接收变量s代表 代表被遍历到的集合元素
    		System.out.println(s);
    	}
	}
}
</code></pre>
<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h1 id="第三章-泛型">第三章 泛型</h1>
<h2 id="31-泛型概述">3.1  泛型概述</h2>
<p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<pre><code class="language-java">public class GenericDemo {
	public static void main(String[] args) {
		Collection coll = new ArrayList();
		coll.add(&quot;abc&quot;);
		coll.add(&quot;itcast&quot;);
		coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放
		Iterator it = coll.iterator();
		while(it.hasNext()){
			//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型
			String str = (String) it.next();
			System.out.println(str.length());
		}
	}
}
</code></pre>
<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li>
</ul>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<h2 id="32-使用泛型的好处">3.2  使用泛型的好处</h2>
<p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<pre><code class="language-java">public class GenericDemo2 {
	public static void main(String[] args) {
        Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;abc&quot;);
        list.add(&quot;itcast&quot;);
        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错
        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型
        Iterator&lt;String&gt; it = list.iterator();
        while(it.hasNext()){
            String str = it.next();
            //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型
            System.out.println(str.length());
        }
	}
}
</code></pre>
<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="33-泛型的定义与使用">3.3  泛型的定义与使用</h2>
<p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类">定义和使用含有泛型的类</h3>
<p>定义格式：</p>
<pre><code>修饰符 class 类名&lt;代表泛型的变量&gt; {  }
</code></pre>
<p>例如，API中的ArrayList集合：</p>
<pre><code class="language-java">class ArrayList&lt;E&gt;{ 
    public boolean add(E e){ }

    public E get(int index){ }
   	....
}
</code></pre>
<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p>例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<pre><code class="language-java">class ArrayList&lt;String&gt;{ 
     public boolean add(String e){ }

     public String get(int index){  }
     ...
}
</code></pre>
<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<pre><code class="language-java">class ArrayList&lt;Integer&gt; { 
     public boolean add(Integer e) { }

     public Integer get(int index) {  }
     ...
}
</code></pre>
<p>举例自定义泛型类</p>
<pre><code class="language-java">public class MyGenericClass&lt;MVP&gt; {
	//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型
	private MVP mvp;
     
    public void setMVP(MVP mvp) {
        this.mvp = mvp;
    }
     
    public MVP getMVP() {
        return mvp;
    }
}
</code></pre>
<p>使用:</p>
<pre><code class="language-java">public class GenericClassDemo {
  	public static void main(String[] args) {		 
         // 创建一个泛型为String的类
         MyGenericClass&lt;String&gt; my = new MyGenericClass&lt;String&gt;();    	
         // 调用setMVP
         my.setMVP(&quot;大胡子登登&quot;);
         // 调用getMVP
         String mvp = my.getMVP();
         System.out.println(mvp);
         //创建一个泛型为Integer的类
         MyGenericClass&lt;Integer&gt; my2 = new MyGenericClass&lt;Integer&gt;(); 
         my2.setMVP(123);   	  
         Integer mvp2 = my2.getMVP();
    }
}
</code></pre>
<h3 id="含有泛型的方法">含有泛型的方法</h3>
<p>定义格式：</p>
<pre><code>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){  }
</code></pre>
<p>例如，</p>
<pre><code class="language-java">public class MyGenericMethod {	  
    public &lt;MVP&gt; void show(MVP mvp) {
    	System.out.println(mvp.getClass());
    }
    
    public &lt;MVP&gt; MVP show2(MVP mvp) {	
    	return mvp;
    }
}
</code></pre>
<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<pre><code class="language-java">public class GenericMethodDemo {
    public static void main(String[] args) {
        // 创建对象
        MyGenericMethod mm = new MyGenericMethod();
        // 演示看方法提示
        mm.show(&quot;aaa&quot;);
        mm.show(123);
        mm.show(12.45);
    }
}
</code></pre>
<h3 id="含有泛型的接口">含有泛型的接口</h3>
<p>定义格式：</p>
<pre><code>修饰符 interface接口名&lt;代表泛型的变量&gt; {  }
</code></pre>
<p>例如，</p>
<pre><code class="language-java">public interface MyGenericInterface&lt;E&gt;{
	public abstract void add(E e);
	
	public abstract E getE();  
}
</code></pre>
<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<pre><code class="language-java">public class MyImp1 implements MyGenericInterface&lt;String&gt; {
	@Override
    public void add(String e) {
        // 省略...
    }

	@Override
	public String getE() {
		return null;
	}
}
</code></pre>
<p>此时，泛型E的值就是String类型。</p>
<p><strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p>例如</p>
<pre><code class="language-java">public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; {
	@Override
	public void add(E e) {
       	 // 省略...
	}

	@Override
	public E getE() {
		return null;
	}
}
</code></pre>
<p>确定泛型：</p>
<pre><code class="language-java">/*
 * 使用
 */
public class GenericInterface {
    public static void main(String[] args) {
        MyImp2&lt;String&gt;  my = new MyImp2&lt;String&gt;();  
        my.add(&quot;aa&quot;);
    }
}
</code></pre>
<h2 id="34-泛型通配符">3.4  泛型通配符</h2>
<p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用">通配符基本使用</h4>
<p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;();
    getElement(list1);
    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
    getElement(list2);
}
public static void getElement(Collection&lt;?&gt; coll){}
//？代表可以接收任意类型
</code></pre>
<blockquote>
<p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</p>
</blockquote>
<h4 id="通配符高级使用-受限泛型">通配符高级使用----受限泛型</h4>
<p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<pre><code class="language-java">public static void main(String[] args) {
    Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
    Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;();
    Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;();
    Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;();
    
    getElement(list1);
    getElement(list2);//报错
    getElement(list3);
    getElement(list4);//报错
  
    getElement2(list1);//报错
    getElement2(list2);//报错
    getElement2(list3);
    getElement2(list4);
  
}
// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类
public static void getElement1(Collection&lt;? extends Number&gt; coll){}
// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类
public static void getElement2(Collection&lt;? super Number&gt; coll){}
</code></pre>
<h1 id="第四章-集合综合案例">第四章 集合综合案例</h1>
<h2 id="41-案例介绍">4.1 案例介绍</h2>
<p>按照斗地主的规则，完成洗牌发牌的动作。<br>
具体规则：</p>
<p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p>
<h2 id="42-案例分析">4.2 案例分析</h2>
<ul>
<li>
<p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>
每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>
牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li>
<p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
<li>
<p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<h2 id="43-代码实现">4.3 代码实现</h2>
<pre><code class="language-java">import java.util.ArrayList;
import java.util.Collections;

public class Poker {
    public static void main(String[] args) {
        /*
        * 1: 准备牌操作
        */
        //1.1 创建牌盒 将来存储牌面的 
        ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;();
        //1.2 创建花色集合
        ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;();

        //1.3 创建数字集合
        ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;();

        //1.4 分别给花色 以及 数字集合添加元素
        colors.add(&quot;♥&quot;);
        colors.add(&quot;♦&quot;);
        colors.add(&quot;♠&quot;);
        colors.add(&quot;♣&quot;);

        for(int i = 2;i&lt;=10;i++){
            numbers.add(i+&quot;&quot;);
        }
        numbers.add(&quot;J&quot;);
        numbers.add(&quot;Q&quot;);
        numbers.add(&quot;K&quot;);
        numbers.add(&quot;A&quot;);
        //1.5 创造牌  拼接牌操作
        // 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中
        for (String color : colors) {
            //color每一个花色 
            //遍历数字集合
            for(String number : numbers){
                //结合
                String card = color+number;
                //存储到牌盒中
                pokerBox.add(card);
            }
        }
        //1.6大王小王
        pokerBox.add(&quot;小☺&quot;);
        pokerBox.add(&quot;大☠&quot;);	  
        // System.out.println(pokerBox);
        //洗牌 是不是就是将  牌盒中 牌的索引打乱 
        // Collections类  工具类  都是 静态方法
        // shuffer方法   
        /*
         * static void shuffle(List&lt;?&gt; list) 
         *     使用默认随机源对指定列表进行置换。 
         */
        //2:洗牌
        Collections.shuffle(pokerBox);
        //3 发牌
        //3.1 创建 三个 玩家集合  创建一个底牌集合
        ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();
        ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;();	  

        //遍历 牌盒  必须知道索引   
        for(int i = 0;i&lt;pokerBox.size();i++){
            //获取 牌面
            String card = pokerBox.get(i);
            //留出三张底牌 存到 底牌集合中
            if(i&gt;=51){//存到底牌集合中
                dipai.add(card);
            } else {
                //玩家1   %3  ==0
                if(i%3==0){
                  	player1.add(card);
                }else if(i%3==1){//玩家2
                  	player2.add(card);
                }else{//玩家3
                  	player3.add(card);
                }
            }
        }
        //看看
        System.out.println(&quot;令狐冲：&quot;+player1);
        System.out.println(&quot;田伯光：&quot;+player2);
        System.out.println(&quot;绿竹翁：&quot;+player3);
        System.out.println(&quot;底牌：&quot;+dipai);  
	}
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#day02collection-%E6%B3%9B%E5%9E%8B">day02【Collection、泛型】</a>
<ul>
<li><a href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9">主要内容</a></li>
<li><a href="#%E6%95%99%E5%AD%A6%E7%9B%AE%E6%A0%87">教学目标</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-collection%E9%9B%86%E5%90%88">第一章 Collection集合</a>
<ul>
<li><a href="#11-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0">1.1 集合概述</a></li>
<li><a href="#12-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">1.2  集合框架</a></li>
<li><a href="#13-collection-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD">1.3 Collection 常用功能</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-iterator%E8%BF%AD%E4%BB%A3%E5%99%A8">第二章 Iterator迭代器</a></li>
<li><a href="#21-iterator%E6%8E%A5%E5%8F%A3">2.1 Iterator接口</a></li>
<li><a href="#22-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">2.2 迭代器的实现原理</a></li>
<li><a href="#23-%E5%A2%9E%E5%BC%BAfor">2.3 增强for</a><br>
*
<ul>
<li><a href="#%E7%BB%83%E4%B9%A01%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84">练习1：遍历数组</a></li>
<li><a href="#%E7%BB%83%E4%B9%A02%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88">练习2:遍历集合</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B3%9B%E5%9E%8B">第三章 泛型</a>
<ul>
<li><a href="#31-%E6%B3%9B%E5%9E%8B%E6%A6%82%E8%BF%B0">3.1  泛型概述</a></li>
<li><a href="#32-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84">3.2  使用泛型的好处</a></li>
<li><a href="#33-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8">3.3  泛型的定义与使用</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB">定义和使用含有泛型的类</a></li>
<li><a href="#%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">含有泛型的方法</a></li>
<li><a href="#%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%8E%A5%E5%8F%A3">含有泛型的接口</a></li>
</ul>
</li>
<li><a href="#34-%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6">3.4  泛型通配符</a><br>
*
<ul>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">通配符基本使用</a></li>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8-%E5%8F%97%E9%99%90%E6%B3%9B%E5%9E%8B">通配符高级使用----受限泛型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9B%86%E5%90%88%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B">第四章 集合综合案例</a>
<ul>
<li><a href="#41-%E6%A1%88%E4%BE%8B%E4%BB%8B%E7%BB%8D">4.1 案例介绍</a></li>
<li><a href="#42-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">4.2 案例分析</a></li>
<li><a href="#43-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">4.3 代码实现</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://huihe524.github.io/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://huihe524.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
